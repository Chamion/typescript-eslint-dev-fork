"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectGraphFromServer = exports.isServerAvailable = exports.stop = exports.startInCurrentProcess = exports.startInBackground = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const net_1 = require("net");
const perf_hooks_1 = require("perf_hooks");
const cache_1 = require("../cache");
const socket_utils_1 = require("../socket-utils");
const tmp_dir_1 = require("../tmp-dir");
function startInBackground() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield cache_1.safelyCleanUpExistingProcess();
        try {
            const out = fs_1.openSync(tmp_dir_1.DAEMON_OUTPUT_LOG_FILE, 'a');
            const err = fs_1.openSync(tmp_dir_1.DAEMON_OUTPUT_LOG_FILE, 'a');
            const backgroundProcess = child_process_1.spawn(process.execPath, ['../server/start.js'], {
                cwd: __dirname,
                stdio: ['ignore', out, err],
                detached: true,
            });
            backgroundProcess.unref();
            // Persist metadata about the background process so that it can be cleaned up later if needed
            yield cache_1.writeDaemonJsonProcessCache({
                processId: backgroundProcess.pid,
            });
            /**
             * Ensure the server is actually available to connect to via IPC before resolving
             */
            return new Promise((resolve) => {
                const id = setInterval(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (yield isServerAvailable()) {
                        clearInterval(id);
                        resolve(backgroundProcess.pid);
                    }
                }), 500);
            });
        }
        catch (err) {
            devkit_1.logger.error(err);
            process.exit(1);
        }
    });
}
exports.startInBackground = startInBackground;
function startInCurrentProcess() {
    devkit_1.logger.info(`NX Daemon Server - Starting in the current process...`);
    child_process_1.spawnSync(process.execPath, ['../server/start.js'], {
        cwd: __dirname,
        stdio: 'inherit',
    });
}
exports.startInCurrentProcess = startInCurrentProcess;
function stop() {
    child_process_1.spawnSync(process.execPath, ['../server/stop.js'], {
        cwd: __dirname,
        stdio: 'inherit',
    });
    devkit_1.logger.info('NX Daemon Server - Stopped');
}
exports.stop = stop;
/**
 * As noted in the comments above the createServer() call, in order to reliably (meaning it works
 * cross-platform) check whether or not the server is availabe to request a project graph from we
 * need to actually attempt connecting to it.
 *
 * Because of the behavior of named pipes on Windows, we cannot simply treat them as a file and
 * check for their existence on disk (unlike with Unix Sockets).
 */
function isServerAvailable() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            try {
                const socket = net_1.connect(socket_utils_1.FULL_OS_SOCKET_PATH, () => {
                    socket.destroy();
                    resolve(true);
                });
                socket.once('error', () => {
                    resolve(false);
                });
            }
            catch (err) {
                resolve(false);
            }
        });
    });
}
exports.isServerAvailable = isServerAvailable;
/**
 * Establishes a client connection to the daemon server for use in project graph
 * creation utilities.
 *
 * All logs are performed by the devkit logger because this logic does not
 * run "on the server" per se and therefore does not write to its log output.
 *
 * TODO: Gracefully handle a server shutdown (for whatever reason) while a client
 * is connecting and querying it.
 */
function getProjectGraphFromServer() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            perf_hooks_1.performance.mark('getProjectGraphFromServer-start');
            const socket = net_1.connect(socket_utils_1.FULL_OS_SOCKET_PATH);
            socket.on('error', (err) => {
                let errorMessage;
                if (err.message.startsWith('connect ENOENT')) {
                    errorMessage = 'Error: The Daemon Server is not running';
                }
                if (err.message.startsWith('connect ECONNREFUSED')) {
                    // If somehow the file descriptor had not been released during a previous shut down.
                    if (fs_1.existsSync(socket_utils_1.FULL_OS_SOCKET_PATH)) {
                        errorMessage = `Error: A server instance had not been fully shut down. Please try running the command again.`;
                        socket_utils_1.killSocketOrPath();
                    }
                }
                devkit_1.logger.error(`NX Daemon Client - ${errorMessage || err}`);
                return reject(new Error(errorMessage) || err);
            });
            /**
             * Immediately after connecting to the server we send it the known project graph creation
             * request payload. See the notes above createServer() for more context as to why we explicitly
             * request the graph from the client like this.
             */
            socket.on('connect', () => {
                socket.write('REQUEST_PROJECT_GRAPH_PAYLOAD');
                let serializedProjectGraphResult = '';
                socket.on('data', (data) => {
                    serializedProjectGraphResult += data.toString();
                });
                socket.on('end', () => {
                    try {
                        perf_hooks_1.performance.mark('json-parse-start');
                        const projectGraphResult = socket_utils_1.deserializeResult(serializedProjectGraphResult);
                        perf_hooks_1.performance.mark('json-parse-end');
                        perf_hooks_1.performance.measure('deserialize graph result on the client', 'json-parse-start', 'json-parse-end');
                        if (projectGraphResult.error) {
                            devkit_1.logger.error(`NX Daemon Client - The server returned an Error`);
                            return reject(projectGraphResult.error);
                        }
                        perf_hooks_1.performance.measure('total for getProjectGraphFromServer()', 'getProjectGraphFromServer-start', 'json-parse-end');
                        return resolve(projectGraphResult.projectGraph);
                    }
                    catch (_a) {
                        devkit_1.logger.error('NX Daemon Client - Error: Could not deserialize the ProjectGraph');
                        return reject(new Error('Could not deserialize the ProjectGraph'));
                    }
                });
            });
        });
    });
}
exports.getProjectGraphFromServer = getProjectGraphFromServer;
//# sourceMappingURL=client.js.map