"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetInternalState = exports.addUpdatedAndDeletedFiles = exports.getCachedSerializedProjectGraphPromise = void 0;
const tslib_1 = require("tslib");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const perf_hooks_1 = require("perf_hooks");
const file_utils_1 = require("../../../file-utils");
const file_hasher_1 = require("../../../hasher/file-hasher");
const git_hasher_1 = require("../../../hasher/git-hasher");
const logger_1 = require("./logger");
const build_project_graph_1 = require("../../build-project-graph");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const nx_deps_cache_1 = require("../../../nx-deps/nx-deps-cache");
const fileutils_1 = require("../../../../utilities/fileutils");
const configName = workspace_1.workspaceConfigName(app_root_1.appRootPath);
let cachedSerializedProjectGraphPromise;
let projectFileMapWithFiles;
let currentProjectGraphCache;
const collectedUpdatedFiles = new Set();
const collectedDeletedFiles = new Set();
let waitPeriod = 100;
let scheduledTimeoutId;
function getCachedSerializedProjectGraphPromise() {
    // recomputing it now on demand. we can ignore the scheduled timeout
    if (scheduledTimeoutId) {
        clearTimeout(scheduledTimeoutId);
        scheduledTimeoutId = undefined;
    }
    // reset the wait time
    waitPeriod = 100;
    resetInternalStateIfNxDepsMissing();
    if (collectedUpdatedFiles.size == 0 && collectedDeletedFiles.size == 0) {
        if (!cachedSerializedProjectGraphPromise) {
            processCollectedUpdatedAndDeletedFiles(); // this creates a project graph
            cachedSerializedProjectGraphPromise = createAndSerializeProjectGraph();
        }
    }
    else {
        processCollectedUpdatedAndDeletedFiles();
        cachedSerializedProjectGraphPromise = createAndSerializeProjectGraph();
    }
    return cachedSerializedProjectGraphPromise;
}
exports.getCachedSerializedProjectGraphPromise = getCachedSerializedProjectGraphPromise;
function addUpdatedAndDeletedFiles(updatedFiles, deletedFiles) {
    for (let f of updatedFiles) {
        collectedDeletedFiles.delete(f);
        collectedUpdatedFiles.add(f);
    }
    for (let f of deletedFiles) {
        collectedUpdatedFiles.delete(f);
        collectedDeletedFiles.add(f);
    }
    if (!scheduledTimeoutId) {
        scheduledTimeoutId = setTimeout(() => {
            scheduledTimeoutId = undefined;
            if (waitPeriod < 4000) {
                waitPeriod = waitPeriod * 2;
            }
            processCollectedUpdatedAndDeletedFiles();
            cachedSerializedProjectGraphPromise = createAndSerializeProjectGraph();
        }, waitPeriod);
    }
}
exports.addUpdatedAndDeletedFiles = addUpdatedAndDeletedFiles;
function processCollectedUpdatedAndDeletedFiles() {
    perf_hooks_1.performance.mark('hash-watched-changes-start');
    const updatedFiles = git_hasher_1.getGitHashForFiles([...collectedUpdatedFiles.values()], app_root_1.appRootPath);
    const deletedFiles = [...collectedDeletedFiles.values()];
    collectedUpdatedFiles.clear();
    collectedDeletedFiles.clear();
    perf_hooks_1.performance.mark('hash-watched-changes-end');
    perf_hooks_1.performance.measure('hash changed files from watcher', 'hash-watched-changes-start', 'hash-watched-changes-end');
    file_hasher_1.defaultFileHasher.incrementalUpdate(updatedFiles, deletedFiles);
    const workspaceJson = file_utils_1.readWorkspaceJson();
    logger_1.serverLogger.nestedLog(`Updated file-hasher based on watched changes, recomputing project graph...`);
    // when workspace.json changes we cannot be sure about the correctness of the project file map
    if (collectedUpdatedFiles.has(configName) ||
        collectedDeletedFiles.has(configName)) {
        projectFileMapWithFiles = file_utils_1.createProjectFileMap(workspaceJson);
    }
    else {
        projectFileMapWithFiles = projectFileMapWithFiles
            ? file_utils_1.updateProjectFileMap(workspaceJson, projectFileMapWithFiles.projectFileMap, projectFileMapWithFiles.allWorkspaceFiles, updatedFiles, deletedFiles)
            : file_utils_1.createProjectFileMap(workspaceJson);
    }
}
function createAndSerializeProjectGraph() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            perf_hooks_1.performance.mark('create-project-graph-start');
            const workspaceJson = file_utils_1.readWorkspaceJson();
            const { projectGraph, projectGraphCache } = yield build_project_graph_1.buildProjectGraphUsingProjectFileMap(workspaceJson, projectFileMapWithFiles.projectFileMap, projectFileMapWithFiles.allWorkspaceFiles, currentProjectGraphCache || nx_deps_cache_1.readCache(), true);
            currentProjectGraphCache = projectGraphCache;
            perf_hooks_1.performance.mark('create-project-graph-end');
            perf_hooks_1.performance.measure('total execution time for createProjectGraph()', 'create-project-graph-start', 'create-project-graph-end');
            perf_hooks_1.performance.mark('json-stringify-start');
            const serializedProjectGraph = JSON.stringify(projectGraph);
            perf_hooks_1.performance.mark('json-stringify-end');
            perf_hooks_1.performance.measure('serialize graph', 'json-stringify-start', 'json-stringify-end');
            return {
                error: null,
                serializedProjectGraph,
            };
        }
        catch (err) {
            return {
                error: err,
                serializedProjectGraph: null,
            };
        }
    });
}
function resetInternalState() {
    cachedSerializedProjectGraphPromise = undefined;
    projectFileMapWithFiles = undefined;
    currentProjectGraphCache = undefined;
    collectedUpdatedFiles.clear();
    collectedDeletedFiles.clear();
    waitPeriod = 100;
}
exports.resetInternalState = resetInternalState;
function resetInternalStateIfNxDepsMissing() {
    try {
        if (!fileutils_1.fileExists(nx_deps_cache_1.nxDepsPath)) {
            resetInternalState();
        }
    }
    catch (e) {
        resetInternalState();
    }
}
//# sourceMappingURL=project-graph-incremental-recomputation.js.map