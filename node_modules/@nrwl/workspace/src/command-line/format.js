"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveTagsAndImplicitDepsFromNxJsonToWorkspaceJson = exports.format = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path = require("path");
const shared_1 = require("./shared");
const fileutils_1 = require("../utilities/fileutils");
const project_graph_1 = require("../core/project-graph");
const affected_project_graph_1 = require("../core/affected-project-graph");
const file_utils_1 = require("../core/file-utils");
const utils_1 = require("./utils");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const prettier = require("prettier");
const devkit_1 = require("@nrwl/devkit");
const object_sort_1 = require("@nrwl/tao/src/utils/object-sort");
const PRETTIER_PATH = require.resolve('prettier/bin-prettier');
function format(command, args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { nxArgs } = utils_1.splitArgsIntoNxArgsAndOverrides(args, 'affected');
        const workspaceJsonPath = workspace_1.workspaceConfigName(app_root_1.appRootPath);
        const patterns = (yield getPatterns(Object.assign(Object.assign({}, args), nxArgs))).map((p) => `"${p}"`);
        // Chunkify the patterns array to prevent crashing the windows terminal
        const chunkList = chunkify(patterns, 50);
        switch (command) {
            case 'write':
                updateWorkspaceJsonToMatchFormatVersion();
                sortWorkspaceJson();
                sortTsConfig();
                movePropertiesToNewLocations();
                chunkList.push([workspaceJsonPath, 'nx.json', 'tsconfig.base.json']);
                chunkList.forEach((chunk) => write(chunk));
                break;
            case 'check':
                chunkList.forEach((chunk) => check(chunk));
                break;
        }
    });
}
exports.format = format;
function getPatterns(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const supportedExtensions = prettier
            .getSupportInfo()
            .languages.flatMap((language) => language.extensions)
            .filter((extension) => !!extension);
        const matchAllPattern = `**/*{${supportedExtensions.join(',')}}`;
        const allFilesPattern = [matchAllPattern];
        if (args.all) {
            return allFilesPattern;
        }
        try {
            if (args.projects && args.projects.length > 0) {
                return getPatternsFromProjects(args.projects, matchAllPattern);
            }
            const p = shared_1.parseFiles(args);
            const patterns = p.files.filter((f) => fileutils_1.fileExists(f) && supportedExtensions.includes(path.extname(f)));
            return args.libsAndApps
                ? yield getPatternsFromApps(patterns, matchAllPattern)
                : patterns;
        }
        catch (_a) {
            return allFilesPattern;
        }
    });
}
function getPatternsFromApps(affectedFiles, matchAllPattern) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = yield project_graph_1.createProjectGraphAsync();
        const affectedGraph = affected_project_graph_1.filterAffected(graph, file_utils_1.calculateFileChanges(affectedFiles));
        return getPatternsFromProjects(Object.keys(affectedGraph.nodes), matchAllPattern);
    });
}
function getPatternsFromProjects(projects, matchAllPattern) {
    const roots = shared_1.getProjectRoots(projects);
    return roots.map((root) => `${root}/${matchAllPattern}`);
}
function chunkify(target, size) {
    return target.reduce((current, value, index) => {
        if (index % size === 0)
            current.push([]);
        current[current.length - 1].push(value);
        return current;
    }, []);
}
function write(patterns) {
    if (patterns.length > 0) {
        child_process_1.execSync(`node "${PRETTIER_PATH}" --write ${patterns.join(' ')}`, {
            stdio: [0, 1, 2],
        });
    }
}
function check(patterns) {
    if (patterns.length > 0) {
        try {
            child_process_1.execSync(`node "${PRETTIER_PATH}" --list-different ${patterns.join(' ')}`, {
                stdio: [0, 1, 2],
            });
        }
        catch (_a) {
            process.exit(1);
        }
    }
}
function updateWorkspaceJsonToMatchFormatVersion() {
    const workspaceConfig = workspace_1.workspaceConfigName(app_root_1.appRootPath);
    try {
        const workspaceJson = devkit_1.readJsonFile(workspaceConfig);
        const reformatted = workspace_1.reformattedWorkspaceJsonOrNull(workspaceJson);
        if (reformatted) {
            devkit_1.writeJsonFile(workspaceConfig, reformatted);
        }
    }
    catch (e) {
        console.error(`Failed to format: ${path}`);
        console.error(e);
    }
}
function sortWorkspaceJson() {
    const workspaceJsonPath = workspace_1.workspaceConfigName(app_root_1.appRootPath);
    try {
        const workspaceJson = devkit_1.readJsonFile(workspaceJsonPath);
        if (Object.entries(workspaceJson.projects).length !== 0) {
            const sortedProjects = object_sort_1.sortObjectByKeys(workspaceJson.projects);
            workspaceJson.projects = sortedProjects;
            devkit_1.writeJsonFile(workspaceJsonPath, workspaceJson);
        }
    }
    catch (e) {
        // catch noop
    }
}
function sortTsConfig() {
    try {
        const tsconfigPath = path.join(app_root_1.appRootPath, 'tsconfig.base.json');
        const tsconfig = devkit_1.readJsonFile(tsconfigPath);
        const sortedPaths = object_sort_1.sortObjectByKeys(tsconfig.compilerOptions.paths);
        tsconfig.compilerOptions.paths = sortedPaths;
        devkit_1.writeJsonFile(tsconfigPath, tsconfig);
    }
    catch (e) {
        // catch noop
    }
}
function movePropertiesToNewLocations() {
    var _a, _b, _c, _d;
    const workspaceConfig = workspace_1.workspaceConfigName(app_root_1.appRootPath);
    try {
        const workspaceJson = devkit_1.readJsonFile(workspaceConfig);
        const nxJson = devkit_1.readJsonFile('nx.json');
        if (workspaceJson.cli ||
            workspaceJson.generators ||
            nxJson.projects ||
            nxJson.defaultProject) {
            (_a = nxJson.cli) !== null && _a !== void 0 ? _a : (nxJson.cli = workspaceJson.cli);
            (_b = nxJson.generators) !== null && _b !== void 0 ? _b : (nxJson.generators = (_c = workspaceJson.generators) !== null && _c !== void 0 ? _c : workspaceJson.schematics);
            (_d = nxJson.defaultProject) !== null && _d !== void 0 ? _d : (nxJson.defaultProject = workspaceJson.defaultProject);
            delete workspaceJson['cli'];
            delete workspaceJson['generators'];
            delete workspaceJson['defaultProject'];
            moveTagsAndImplicitDepsFromNxJsonToWorkspaceJson(workspaceJson, nxJson);
            devkit_1.writeJsonFile(workspaceConfig, workspaceJson);
            devkit_1.writeJsonFile('nx.json', nxJson);
        }
    }
    catch (e) {
        console.error(`Error moving properties between Nx.Json + ${workspaceConfig}`);
        console.error(e);
    }
}
function moveTagsAndImplicitDepsFromNxJsonToWorkspaceJson(workspaceJson, nxJson) {
    if (!nxJson.projects) {
        return;
    }
    Object.entries(nxJson.projects).forEach(([project, config]) => {
        workspaceJson.projects[project] = Object.assign(Object.assign({}, workspaceJson.projects[project]), config);
    });
    delete nxJson.projects;
}
exports.moveTagsAndImplicitDepsFromNxJsonToWorkspaceJson = moveTagsAndImplicitDepsFromNxJsonToWorkspaceJson;
//# sourceMappingURL=format.js.map