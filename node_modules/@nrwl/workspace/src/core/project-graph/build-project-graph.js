"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildProjectGraphUsingProjectFileMap = exports.buildProjectGraph = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const assert_workspace_validity_1 = require("../assert-workspace-validity");
const file_utils_1 = require("../file-utils");
const normalize_nx_json_1 = require("../normalize-nx-json");
const nx_deps_cache_1 = require("../nx-deps/nx-deps-cache");
const build_dependencies_1 = require("./build-dependencies");
const build_nodes_1 = require("./build-nodes");
const fs_1 = require("fs");
const os = require("os");
const build_explicit_typescript_and_package_json_dependencies_1 = require("./build-dependencies/build-explicit-typescript-and-package-json-dependencies");
function buildProjectGraph() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const workspaceJson = file_utils_1.readWorkspaceJson();
        const { projectFileMap, allWorkspaceFiles } = file_utils_1.createProjectFileMap(workspaceJson);
        const cacheEnabled = process.env.NX_CACHE_PROJECT_GRAPH !== 'false';
        let cache = cacheEnabled ? nx_deps_cache_1.readCache() : null;
        return (yield buildProjectGraphUsingProjectFileMap(workspaceJson, projectFileMap, allWorkspaceFiles, cache, cacheEnabled)).projectGraph;
    });
}
exports.buildProjectGraph = buildProjectGraph;
function buildProjectGraphUsingProjectFileMap(workspaceJson, projectFileMap, allWorkspaceFiles, cache, shouldWriteCache) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const nxJson = file_utils_1.readNxJson();
        const projectGraphVersion = '5.0';
        assert_workspace_validity_1.assertWorkspaceValidity(workspaceJson, nxJson);
        const normalizedNxJson = normalize_nx_json_1.normalizeNxJson(nxJson, Object.keys(workspaceJson.projects));
        const packageJsonDeps = readCombinedDeps();
        const rootTsConfig = readRootTsConfig();
        let filesToProcess = projectFileMap;
        let cachedFileData = {};
        if (cache &&
            !nx_deps_cache_1.shouldRecomputeWholeGraph(cache, packageJsonDeps, workspaceJson, normalizedNxJson, rootTsConfig)) {
            const fromCache = nx_deps_cache_1.extractCachedFileData(projectFileMap, cache);
            filesToProcess = fromCache.filesToProcess;
            cachedFileData = fromCache.cachedFileData;
        }
        const context = createContext(workspaceJson, normalizedNxJson, projectFileMap, filesToProcess);
        let projectGraph = yield buildProjectGraphUsingContext(context, cachedFileData, projectGraphVersion);
        const projectGraphCache = nx_deps_cache_1.createCache(nxJson, packageJsonDeps, projectGraph, rootTsConfig);
        if (shouldWriteCache) {
            nx_deps_cache_1.writeCache(projectGraphCache);
        }
        projectGraph.allWorkspaceFiles = allWorkspaceFiles;
        return {
            projectGraph,
            projectGraphCache,
        };
    });
}
exports.buildProjectGraphUsingProjectFileMap = buildProjectGraphUsingProjectFileMap;
function readCombinedDeps() {
    const json = devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'package.json'));
    return Object.assign(Object.assign({}, json.dependencies), json.devDependencies);
}
function buildProjectGraphUsingContext(ctx, cachedFileData, projectGraphVersion) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        perf_hooks_1.performance.mark('build project graph:start');
        const builder = new devkit_1.ProjectGraphBuilder();
        build_nodes_1.buildWorkspaceProjectNodes(ctx, builder);
        build_nodes_1.buildNpmPackageNodes(builder);
        for (const proj of Object.keys(cachedFileData)) {
            for (const f of builder.graph.nodes[proj].data.files) {
                const cached = cachedFileData[proj][f.file];
                if (cached) {
                    f.deps = cached.deps;
                }
            }
        }
        yield buildExplicitDependencies(ctx, builder);
        build_dependencies_1.buildImplicitProjectDependencies(ctx, builder);
        builder.setVersion(projectGraphVersion);
        const initProjectGraph = builder.getUpdatedProjectGraph();
        const r = updateProjectGraphWithPlugins(ctx, initProjectGraph);
        perf_hooks_1.performance.mark('build project graph:end');
        perf_hooks_1.performance.measure('build project graph', 'build project graph:start', 'build project graph:end');
        return r;
    });
}
function buildExplicitDependencies(ctx, builder) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let totalNumOfFilesToProcess = totalNumberOfFilesToProcess(ctx);
        // using workers has an overhead, so we only do it when the number of
        // files we need to process is >= 100
        if (totalNumOfFilesToProcess < 100) {
            return buildExplicitDependenciesWithoutWorkers(ctx, builder);
        }
        else {
            return buildExplicitDependenciesUsingWorkers(ctx, totalNumOfFilesToProcess, builder);
        }
    });
}
function totalNumberOfFilesToProcess(ctx) {
    let totalNumOfFilesToProcess = 0;
    Object.values(ctx.filesToProcess).forEach((t) => (totalNumOfFilesToProcess += t.length));
    return totalNumOfFilesToProcess;
}
function splitFilesIntoBins(ctx, totalNumOfFilesToProcess, numberOfWorkers) {
    // we want to have numberOfWorkers * 5 bins
    const filesPerBin = Math.round(totalNumOfFilesToProcess / numberOfWorkers / 5) + 1;
    const bins = [];
    let currentProjectFileMap = {};
    let currentNumberOfFiles = 0;
    for (const source of Object.keys(ctx.filesToProcess)) {
        for (const f of Object.values(ctx.filesToProcess[source])) {
            if (!currentProjectFileMap[source])
                currentProjectFileMap[source] = [];
            currentProjectFileMap[source].push(f);
            currentNumberOfFiles++;
            if (currentNumberOfFiles >= filesPerBin) {
                bins.push(currentProjectFileMap);
                currentProjectFileMap = {};
                currentNumberOfFiles = 0;
            }
        }
    }
    bins.push(currentProjectFileMap);
    return bins;
}
function createWorkerPool(numberOfWorkers) {
    const res = [];
    for (let i = 0; i < numberOfWorkers; ++i) {
        res.push(new (require('worker_threads').Worker)(path_1.join(__dirname, './project-graph-worker.js'), {
            env: process.env,
        }));
    }
    return res;
}
function buildExplicitDependenciesWithoutWorkers(ctx, builder) {
    build_explicit_typescript_and_package_json_dependencies_1.buildExplicitTypescriptAndPackageJsonDependencies(ctx.workspace, builder.graph, ctx.filesToProcess).forEach((r) => {
        builder.addExplicitDependency(r.sourceProjectName, r.sourceProjectFile, r.targetProjectName);
    });
}
function buildExplicitDependenciesUsingWorkers(ctx, totalNumOfFilesToProcess, builder) {
    const numberOfWorkers = os.cpus().length - 1;
    const bins = splitFilesIntoBins(ctx, totalNumOfFilesToProcess, numberOfWorkers);
    const workers = createWorkerPool(numberOfWorkers);
    let numberOfExpectedResponses = bins.length;
    return new Promise((res, reject) => {
        for (let w of workers) {
            w.on('message', (explicitDependencies) => {
                explicitDependencies.forEach((r) => {
                    builder.addExplicitDependency(r.sourceProjectName, r.sourceProjectFile, r.targetProjectName);
                });
                if (bins.length > 0) {
                    w.postMessage({ filesToProcess: bins.shift() });
                }
                // we processed all the bins
                if (--numberOfExpectedResponses === 0) {
                    for (let w of workers) {
                        w.terminate();
                    }
                    res(null);
                }
            });
            w.on('error', reject);
            w.on('exit', (code) => {
                if (code !== 0) {
                    reject(new Error(`Unable to complete project graph creation. Worker stopped with exit code: ${code}`));
                }
            });
            w.postMessage({
                workspace: ctx.workspace,
                projectGraph: builder.graph,
            });
            w.postMessage({ filesToProcess: bins.shift() });
        }
    });
}
function createContext(workspaceJson, nxJson, fileMap, filesToProcess) {
    const projects = Object.keys(workspaceJson.projects).reduce((map, projectName) => {
        map[projectName] = Object.assign({}, workspaceJson.projects[projectName]);
        return map;
    }, {});
    return {
        workspace: Object.assign(Object.assign(Object.assign({}, workspaceJson), nxJson), { projects }),
        fileMap,
        filesToProcess,
    };
}
function updateProjectGraphWithPlugins(context, initProjectGraph) {
    return (context.workspace.plugins || []).reduce((graph, path) => {
        try {
            const pluginPath = require.resolve(path, {
                paths: [app_root_1.appRootPath],
            });
            const pluginModule = require(pluginPath);
            if (!pluginModule.processProjectGraph) {
                return graph;
            }
            return pluginModule.processProjectGraph(graph, context);
        }
        catch (e) {
            const message = `Failed to process the project graph with "${path}". This will error in the future!`;
            if (process.env.NX_VERBOSE_LOGGING === 'true') {
                console.error(e);
                devkit_1.logger.error(message);
                return graph;
            }
            else {
                devkit_1.logger.warn(message);
                devkit_1.logger.warn(`Run with NX_VERBOSE_LOGGING=true to see the error.`);
            }
            return graph;
        }
    }, initProjectGraph);
}
function readRootTsConfig() {
    for (const tsConfigName of ['tsconfig.base.json', 'tsconfig.json']) {
        const tsConfigPath = path_1.join(app_root_1.appRootPath, tsConfigName);
        if (fs_1.existsSync(tsConfigPath)) {
            return devkit_1.readJsonFile(tsConfigPath);
        }
    }
}
//# sourceMappingURL=build-project-graph.js.map