"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopServer = exports.startServer = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const net_1 = require("net");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const socket_utils_1 = require("../socket-utils");
const logger_1 = require("./logger");
const shutdown_utils_1 = require("./shutdown-utils");
const watcher_1 = require("./watcher");
const project_graph_incremental_recomputation_1 = require("./project-graph-incremental-recomputation");
function respondToClient(socket, message) {
    socket.write(message, () => {
        // Close the connection once all data has been written so that the client knows when to read it.
        socket.end();
        logger_1.serverLogger.nestedLog(`Closed Connection to Client`);
    });
}
let watcherSubscription;
let performanceObserver;
const server = net_1.createServer((socket) => {
    shutdown_utils_1.resetInactivityTimeout(handleInactivityTimeout);
    if (!performanceObserver) {
        performanceObserver = new perf_hooks_1.PerformanceObserver((list) => {
            const entry = list.getEntries()[0];
            logger_1.serverLogger.nestedLog(`Time taken for '${entry.name}'`, `${entry.duration}ms`);
        });
        performanceObserver.observe({ entryTypes: ['measure'], buffered: false });
    }
    socket.on('data', (data) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        shutdown_utils_1.resetInactivityTimeout(handleInactivityTimeout);
        const payload = data.toString();
        if (payload !== 'REQUEST_PROJECT_GRAPH_PAYLOAD') {
            throw new Error(`Unsupported payload sent to daemon server: ${payload}`);
        }
        perf_hooks_1.performance.mark('server-connection');
        logger_1.serverLogger.requestLog('Client Request for Project Graph Received');
        const result = yield project_graph_incremental_recomputation_1.getCachedSerializedProjectGraphPromise();
        if (result.error) {
            project_graph_incremental_recomputation_1.resetInternalState();
            logger_1.serverLogger.nestedLog(`Error when preparing serialized project graph: ${result.error.message}`);
            respondToClient(socket, socket_utils_1.serializeResult(result.error, result.serializedProjectGraph));
            return;
        }
        const serializedResult = socket_utils_1.serializeResult(result.error, result.serializedProjectGraph);
        if (!serializedResult) {
            project_graph_incremental_recomputation_1.resetInternalState();
            logger_1.serverLogger.nestedLog(`Error when serializing project graph result`);
            respondToClient(socket, socket_utils_1.serializeResult(new Error('Critical error when serializing server result, check server logs'), null));
            return;
        }
        perf_hooks_1.performance.mark('serialized-project-graph-ready');
        perf_hooks_1.performance.measure('total for creating and serializing project graph', 'server-connection', 'serialized-project-graph-ready');
        socket.write(serializedResult, () => {
            perf_hooks_1.performance.mark('serialized-project-graph-written-to-client');
            perf_hooks_1.performance.measure('write project graph to socket', 'serialized-project-graph-ready', 'serialized-project-graph-written-to-client');
            // Close the connection once all data has been written so that the client knows when to read it.
            socket.end();
            perf_hooks_1.performance.measure('total for server response', 'server-connection', 'serialized-project-graph-written-to-client');
            const bytesWritten = Buffer.byteLength(result.serializedProjectGraph, 'utf-8');
            logger_1.serverLogger.nestedLog(`Closed Connection to Client (${bytesWritten} bytes transferred)`);
        });
    }));
});
function handleInactivityTimeout() {
    shutdown_utils_1.handleServerProcessTermination({
        server,
        watcherSubscription,
        reason: `${shutdown_utils_1.SERVER_INACTIVITY_TIMEOUT_MS}ms of inactivity`,
    });
}
process
    .on('SIGINT', () => shutdown_utils_1.handleServerProcessTermination({
    server,
    watcherSubscription,
    reason: 'received process SIGINT',
}))
    .on('SIGTERM', () => shutdown_utils_1.handleServerProcessTermination({
    server,
    watcherSubscription,
    reason: 'received process SIGTERM',
}))
    .on('SIGHUP', () => shutdown_utils_1.handleServerProcessTermination({
    server,
    watcherSubscription,
    reason: 'received process SIGHUP',
}));
function requireUncached(module) {
    delete require.cache[require.resolve(module)];
    return require(module);
}
/**
 * We need to ensure that the server shuts down if the Nx installation changes.
 */
let cachedNxVersion = resolveCurrentNxVersion();
function resolveCurrentNxVersion() {
    const nrwlWorkspacePackageJsonPath = devkit_1.normalizePath(path_1.join(app_root_1.appRootPath, 'node_modules/@nrwl/workspace/package.json'));
    try {
        const { version } = requireUncached(nrwlWorkspacePackageJsonPath);
        return version;
    }
    catch (_a) {
        logger_1.serverLogger.nestedLog(`Error: Could not determine the current Nx version by inspecting: ${nrwlWorkspacePackageJsonPath}`);
        return null;
    }
}
function isNxVersionSame(currentNxVersion) {
    if (currentNxVersion === null) {
        // Something has gone wrong with figuring out the Nx version, declare the version as having changed
        return false;
    }
    return currentNxVersion === cachedNxVersion;
}
/**
 * When applicable files in the workspaces are changed (created, updated, deleted),
 * we need to recompute the cached serialized project graph so that it is readily
 * available for the next client request to the server.
 */
const handleWorkspaceChanges = (err, changeEvents) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    shutdown_utils_1.resetInactivityTimeout(handleInactivityTimeout);
    if (!isNxVersionSame(resolveCurrentNxVersion())) {
        yield shutdown_utils_1.handleServerProcessTermination({
            server,
            watcherSubscription,
            reason: '@nrwl/workspace installation changed',
        });
        return;
    }
    if (err || !changeEvents || !changeEvents.length) {
        logger_1.serverLogger.watcherLog('Unexpected Error');
        console.error(err);
        return;
    }
    logger_1.serverLogger.watcherLog(watcher_1.convertChangeEventsToLogMessage(changeEvents));
    try {
        const filesToHash = [];
        const deletedFiles = [];
        for (const event of changeEvents) {
            if (event.type === 'delete') {
                deletedFiles.push(event.path);
            }
            else {
                filesToHash.push(event.path);
            }
        }
        project_graph_incremental_recomputation_1.addUpdatedAndDeletedFiles(filesToHash, deletedFiles);
    }
    catch (err) {
        logger_1.serverLogger.log(`Unexpected Error`);
        console.error(err);
    }
});
function startServer() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // See notes in socket-utils.ts on OS differences regarding clean up of existings connections.
        if (!socket_utils_1.isWindows) {
            socket_utils_1.killSocketOrPath();
        }
        return new Promise((resolve) => {
            server.listen(socket_utils_1.FULL_OS_SOCKET_PATH, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                logger_1.serverLogger.log(`Started listening on: ${socket_utils_1.FULL_OS_SOCKET_PATH}`);
                if (!watcherSubscription) {
                    watcherSubscription = yield watcher_1.subscribeToWorkspaceChanges(handleWorkspaceChanges);
                    logger_1.serverLogger.watcherLog(`Subscribed to changes within: ${app_root_1.appRootPath}`);
                }
                return resolve(server);
            }));
        });
    });
}
exports.startServer = startServer;
function stopServer() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            server.close((err) => {
                if (err) {
                    /**
                     * If the server is running in a detached background process then server.close()
                     * will throw this error even if server is actually alive. We therefore only reject
                     * in case of any other unexpected errors.
                     */
                    if (!err.message.startsWith('Server is not running')) {
                        return reject(err);
                    }
                }
                socket_utils_1.killSocketOrPath();
                return resolve();
            });
        });
    });
}
exports.stopServer = stopServer;
//# sourceMappingURL=server.js.map